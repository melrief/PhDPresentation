{-# LANGUAGE OverloadedStrings #-}
module Presentation where

import Data.Monoid
import Text.LaTeX.Base hiding (item)
import Text.LaTeX.Packages.AMSMath hiding (pm)
import Text.LaTeX.Packages.Beamer
import Text.LaTeX.Packages.Graphicx
import Text.LaTeX.Packages.Inputenc
import Text.LaTeX.Packages.Hyperref
import Prelude hiding (and)

import Commands
import Utils


presentation :: Monad m => FilePath -> LaTeXT_ m
presentation styleFilePath = do

  documentclass [] beamer

  usepackage []     graphicx
  usepackage []     hyperref
  usepackage [utf8] inputenc
  usepackage []     "appendixnumberbeamer"
  usepackage []     "array"
  usepackage []     "hyperxmp" -- for pdfcopyright and pdflicenseurl
  usepackage []     "marvosym"
  usepackage []     "multirow"
  usepackage []     "pgfplots"
  usepackage []     "textcomp"
  usepackage []     "url"


  nonavigationsymbols

  -- instead of usetheme, we import the style file with the full path that is
  -- given in input (it is generated by main)
  usepackage [] styleFilePath

  -- presentation informations
  title     "Ph.D. Thesis Defense"
  author    "Mario Pastorelli"
  date      "18 July 2014"
  institute (Just "EURECOM") ""

  -- pdf license informations
  hypersetup [("pdfcopyright","Creative Commons Attribution 4.0 International")
             ,("pdflicenseurl","http://creativecommons.org/licenses/by/4.0/")]


  document $ do
    frame presTitle
    
    frame context1
    frame context2
    frame context3
    frame motivations
    frame sizebasedexample
    frame challenges

    frame $ titleinthemiddle "The Hadoop Fair Sojourn Protocol"
    frame hfsp
    frame jobestimation1
    frame agingmodule
    frame agingmodule2
    frame schedulerpolicy

    frame $ titleinthemiddle "Experimental Evaluation"
    frame experimentssetup
    frame experimentsmetrics
    frame experiments
    frame experiments2

    frame $ titleinthemiddle "Impact of the errors"
    frame errors
    frame errors2
    frame errorsFSP

    frame $ titleinthemiddle "Task Preemption"
    frame kill 
    frame killres
    frame suspfast

    frame $ titleinthemiddle "Conclusions"
    frame conclusion
    frame futurework

    frame $ "" -- empty page between normal and backup slides


    -- backup slides

    appendix -- different numbering for backup slides...

    frame $ titleinthemiddle "Size-Based Scheduling with Estimated Sizes"
    frame overunderest
    frame fspps

    frame $ titleinthemiddle "OS-Assisted Task Preemption"
    frame susp1
    frame susptrash
    frame suspexp
    frame suspconc


presTitle :: Monad m => LaTeXT_ m
presTitle = do

  vspace $ Cm 1

  block "" $ center $ textbf $ usebeamercolor "fg" "alerted text" <>
      large3 "Size-Based Disciplines for Job Scheduling in Data-Intensive Scalable Computing Systems"

  vspace $ Cm 0.4

  center (large2 "Mario Pastorelli")

  vspace $ Cm 1

  minipage (Just Top) (".5" <> textwidth) $ flushleft $ scriptsize $ do
      emph "Jury:" <> newline
      vspace $ Cm (-0.15)
      "Prof. Ernst BIERSACK" <> newline
      vspace $ Cm (-0.15)
      "Prof. Guillaume URVOY-KELLER" <> newline
      vspace $ Cm (-0.15)
      "Prof. Giovanni CHIOLA" <> newline
      vspace $ Cm (-0.15)
      "Dr. Patrick BROWN"

  minipage (Just Top) (".5" <> textwidth) $ scriptsize $ do
    flushright $ emph "Supervisor:"
    vspace $ Cm (-0.7)
    flushright "Prof. Pietro MICHIARDI"


context1 :: Monad m => LaTeXT_ m
context1 = do
  frametitle "Context 1/3"

  itemize $ do
    item $ do
      "In 2004, Google presented" <.> textbf "MapReduce"
      ", a system used to process large quantity of data. The key ideas are:"
      itemize $ do
        item $ textbf "Client-Server" <.> "architecture"
        item $ textbf "Move the computation" <> ", not the data"
        item $ do
          "Programming model inspired by" <.> textbf "Lisp" <.> "lists functions:"

          newline
          vspace $ Cm (-0.3)

          center $ mappend (hspace $ Cm (-2)) $ tabular' [l] $ do
                  raw "$map:\\ \\ \\ (k_1,v_1)\\ \\rightarrow[(k_2,v_2)]$"
                  lnbk
                  raw "$reduce: (k_2,[v_2])\\rightarrow[(k_3,v_3)]$" 

    vspace $ Cm 0.5
    pause

    item $ do
      textbf "Hadoop" <> ", the main open-source implementation of MapReduce,"
      " is released one year later. It is widely adopted and used by many "
      "important companies (Facebook, Twitter, Yahoo, IBM, Microsoft" <> ldots <> ")"


context2 :: Monad m => LaTeXT_ m
context2 = do
  frametitle "Context 2/3"

  "In MapReduce, the" <.> textbf "Scheduling Policy" <.> "is fundamental"

  vspace $ Cm 0.5

  itemize $ do
    item $ do
      textbf "Complexity" <.> "of the system"
      itemize $ do
        item $ textbf "Distributed resources"
        item $ textbf "Multiple jobs" <.> "running in" <.> textbf "parallel"
        item $ do
          "Jobs are composed by" <.> textbf "two sequential phases"
          ", the" <.> textbf "map" <.> "and the" <.> textbf "reduce" <.> "phase"
        item $ do
          "Each phase is composed by" <.> textbf "multiple tasks"
          ", where each task runs on a" <.> textbf "slot" <.> "of a client"

    vspace $ Cm 0.3
    pause

    item $ do
      textbf "Heterogeneous" <> " workloads"
      itemize $ do
        item $ textbf "Big differences" <.> "in jobs sizes"
        item $ do
          textbf "Interactive jobs" <.> "(" <> emph "e.g."
          " data exploration, algorithm tuning, orchestration jobs"
          ldots <> ") must run as soon as possible" <> ldots
        item $ ldots <> "without impacting" <.> textbf "batch" <.> "jobs too much"
      

context3 :: Monad m => LaTeXT_ m
context3 = do
  frametitle "Context 3/3"

  itemize $ do
    item $ do
      "Schedulers (strive to) optimize " <> textbf "one or more metrics"
      ". For example:"

      itemize $ do
        item $ textbf "Fairness" <> ": how a job is treated compared to the others"
        item $ textbf "Mean response time" <> ": of jobs, that is the responsiveness of the system"
        item ldots

    vspace $ Cm 0.3
    pause

    item $ do
      "Schedulers for Hadoop," <.> emph "e.g." <.> "the" <.> textbf "Fair Scheduler"
      ", focus on" <.> textbf "fairness" <.> "rather than other metrics"

    vspace $ Cm 0.3
    pause

    item $ do 
      textbf "Short response times" <.> "are very important!"
      " Usually there is one or more system administrators making a "
      textbf "manual ad-hoc configuration"
      itemize $ do
        item $ textbf "Fine-tuning" <.> "of the scheduler parameters"
        item $ "Configuration of" <.> textbf "pools of jobs" <.> "with priorities"
        item $ do
          textbf "Complex" <> "," <.> textbf "error prone" <.> "and" <.> textbf "difficult to adapt"
          " to workload/cluster changes"


motivations :: Monad m => LaTeXT_ m
motivations = do
  frametitle "Motivations"

  itemize $ do
    item $  do
      "Size-based schedulers are more" <.> textbf "efficient"
      " than other schedulers (in theory)" <> ldots
      itemize $ do
        item $ "Job priority based on the" <.> textbf "job size"
        item $ textbf "Focus resources" <.> "on a few jobs instead of splitting them among many jobs"

    vspace $ Cm 0.1
    pause

    item $ do
      ldots <> "but (in practice) they are not adopted in" <.> textbf "real systems"
      itemize $ do
        item $ "Job size is" <.> textbf "unknown"
        item $ "No studies on" <.> textbf "applicability to distributed systems"

    vspace $ Cm 0.3
    pause

    item $ do
      "MapReduce is" <.> textbf "suitable" <.> "for size-based scheduling"

      itemize $ do
        item $ "We don't have the job size but we have the time to " <> textbf "estimate" <.> "it"
        item $ do
          textbf "No perfect" <.> "estimation is required" <.> ldots

          itemize $ do
           item $ ldots <.> "as long as" <.> textbf "very different" <.> "jobs are" <.> textbf "sorted correctly"


sizebasedexample :: Monad m => LaTeXT_ m
sizebasedexample = do
  frametitle "Size-Based Schedulers: Example"

  center $ tabular' [l,r] $ do
    jobsizesarrivals & uncover [FromSlide 2] (alert [FromSlide 2] averagesojourntimes)

  center $ tabular' [l,r] $ do
    fair & (vcenter $ includegraphics [customwidth 0.75] "fig/FAIR.eps")
    lnbk
    srpt & (vcenter $ includegraphics [customwidth 0.75] "fig/SRPT.eps")

  where fair = parbox (Just Top) (Em 6.5)
                      (scriptsize $ textbf $ "Processor Sharing")
        srpt = parbox (Just Top) (Em 6.5) $ do
                 vspace $ Cm (-0.5)
                 scriptsize $ textbf $ "Shortest Remaining" <> newline <> "Processing Time" <> newline <> "(SRPT)"
        vcenter f = raisebox (CustomMeasure ("-.45" <> totalheight)) Nothing Nothing f

        jobsizesarrivals = scriptsize $ tabular' (l -|- r -|- r) $ do
                                    textbf "Job" & textbf "Arrival Time" & textbf "Size" <> lnbk
                                    hline
                                    "job1" & "0s"  & "30s" <> lnbk
                                    "job2" & "10s" & "10s" <> lnbk
                                    "job3" & "15s" & "10s"

        averagesojourntimes =  scriptsize $ tabular' (l -|- r) $ do
                                  textbf "Scheduler"  & textbf "AVG sojourn time" <> lnbk
                                  hline <> rowspacing (Ex (-1.5))
                                  "Processor Sharing" & "35s"
                                  lnbk <> rowspacing (Ex (-1.5))
                                  "SRPT"              & textbf "25s"


challenges :: Monad m => LaTeXT_ m
challenges = do
  frametitle "Challenges"

  itemize $ do
    item $ do
      textbf "Job sizes are unknown" <> ": how do you obtain an"
      textbf " approximation" <> " of a job size while the job is running?"

    vspace $ Cm 0.3
    pause

    item $ textbf "Estimation errors" <> ": how do you cope with an approximated size?"
    
    vspace $ Cm 0.3
    pause

    item $ do
      textbf "Scheduler for real and distributed systems"
      ": can we design a size-based scheduler that works for existing systems?"

    vspace $ Cm 0.3
    pause

    item $ do
      textbf "Job preemption" <> ": preemption is fundamental for scheduling,"
      " but current system support it partially. Can we improve that?"


hfsp :: Monad m => LaTeXT_ m
hfsp = do
  frametitle "Hadoop Fair Sojourn Protocol [BIGDATA 2013]"

  "Size-based scheduler for Hadoop that is" <.> textbf "fair"
  " and achieves" <.> textbf "small response times"

  vspace $ Cm 0.3
  pause

  itemize $ do
    item $ do
      "The map and the reduce phases are treated" <.> textbf "independently"
      " and thus a job has" <.> textbf "two sizes"

    vspace $ Cm 0.1
    pause

    item $ "Sizes estimations are done in" <.> "two steps" <.> "by the" <.> textbf "Estimation Module"

    vspace $ Cm 0.1
    pause

    item $ do
      "Estimated sizes are then given in input to the" <.> textbf "Aging Module"
      " that converts them into" <.> textbf "virtual sizes" <.> "to avoid starvation"

    vspace $ Cm 0.1
    pause

    item $ do
      "Schedule jobs with" <.> textbf "smallest virtual sizes"


jobestimation1 :: Monad m => LaTeXT_ m
jobestimation1 = do
  frametitle "Estimation Module"

  itemize $ do
    item $ do
      "Two ways to estimate a job size:"
      itemize $ do
        item $ do
          textbf "Offline" <> ": based on the information available"
          " a priori (num tasks, block size, past history " <> ldots <> "):"
          itemize $ item "available since job submission but not very precise"
        item $ do
          textbf "Online" <> ": based on the performance of a subset"
          " of" <.> texttt "t" <.> "tasks:"
          itemize $ item "need time for training but more precise"

    vspace $ Cm 0.3
    pause

    item $ do
      "We need both:"
      itemize $ do
        item $ do
          "Offline estimation for the " <> textbf "initial size"
          ", because jobs need size since their submission"
        item $ do
          "Online estimation because it is more precise: "
          " when it is completed, the job size is updated to the" <.> textbf "final size"

    vspace $ Cm 0.3
    pause

    item $ do
      textbf "Tiny Jobs" <> ": jobs with less than " <> texttt "t" <> " tasks"
      " are considered tiny and have the highest priority possible"


agingmodule :: Monad m => LaTeXT_ m
agingmodule = do
  frametitle "Aging Module 1/2"

  itemize $ do
    item $ textbf "Aging" <> ": the more a job stays in queue, the" <.> "higher" <.> "its priority will be"

    vspace $ Cm 0.3
    pause

    item $ do
      "A technique used in the literature to age jobs is the" <.> textbf "Virtual Size"

      itemize $ do

        vspace $ Cm 0.1

        item $ "Each job is run in a simulation using" <.> textbf "processor sharing"

        vspace $ Cm 0.1

        item $ do
          "The output of the simulation is the job" <.> textbf "virtual size"
          ", that is the job size aged by the amount of time the job has spent in the simulation"

        vspace $ Cm 0.1

        item $ do
          "Jobs are sorted by" <.> "remaining virtual size" <.> "and resources are assigned to the job with "
          textbf "smallest virtual size"

  center $ do
    minipage (Just Top) (".4" <> textwidth) $ flushleft $ figure' $ do
      includegraphics [customwidth 1] "fig/virtualtime.pdf"
      caption "Virtual Size (Simulation)"

    minipage (Just Top) (".4" <> textwidth) $ flushright $ figure' $ do
      includegraphics [customwidth 1] "fig/size.pdf"
      caption "Real Size (Real Scheduling)"


agingmodule2 :: Monad m => LaTeXT_ m
agingmodule2 = do
  frametitle "Aging Module 2/2"

  itemize $ do
    item $ do
      "In HFSP the estimated sizes are converted in virtual sizes by the Aging Module"

      itemize $ do
        item $ do
          "The simulation is run in a" <.> textbf "virtual cluster"
          " that has the same resources of the real one"
        item $ "Simulating Processor Sharing with " <> textbf "Max-Min Fair Sharing"

    vspace $ Cm 0.5
    pause

    item $ do
      "The" <.> textbf "number of tasks" <.> "of a job determines" <.> textbf "how fast it can age"


schedulerpolicy :: Monad m => LaTeXT_ m
schedulerpolicy = do
  frametitle "Task Scheduling Policy"

  itemize $ do
    item $ do
      "When a job is "<> textbf "submitted"
      itemize $ do
        item $ "If it is" <.> textbf "tiny" <.> "then assign a" <.> textbf "final size" <> "  to it of " <> textbf "0"
        item $ do
          "Else"
          itemize $ do
            item $ "assign an" <.> textbf "initial size" <.> " to it based on its" <.> textbf "number of tasks"
            item $ "mark the job as in" <.> textbf "training stage" <.> "and select" <.> texttt "t" <.> "training tasks"

    vspace $ Cm 0.5
    pause

    item $ do
      "When a resource becomes" <.> textbf "available"
      itemize $ do
        item $ do
          "If there are jobs in the" <.> textbf "training stage"
          " then assign a task from the job with the" <.> textbf "smallest initial virtual size"
        item $ "Else assign a task from the job with the" <.> textbf "smallest final virtual size"


experimentssetup :: Monad m => LaTeXT_ m
experimentssetup = do
  frametitle "Experimental Setup"

  itemize $ do
    item $ "20 TaskTrackers (MapReduce clients) for a total of" <.> textbf "40 map" <.> "and" <.> textbf "20 reduce" <.> "slots"

    vspace $ Cm 0.3
    pause

    item $ "Three kinds of" <.> textbf "workloads" <.> "inspired by existing traces"

  center $ scriptsize $ tabular' (c -|- r -|- r -|- r -|- r -|- r) $ do
    header
    "1" & "1 GB"   & math "<5"       & textbf "65%"&        "30%"  &        "0%"  <> lnbk
    "2" & "10 GB"  & math "10 - 50"  &        "20%"& textbf "40%"  &        "10%" <> lnbk
    "3" & "100 GB" & math "50 - 150" &        "10%"&        "10%"  & textbf "60%" <> lnbk
    "4" & "1 TB"   & math ">150"     &        "5%" &        "20%"  &        "30%" <> lnbk

  pause

  itemize $ do
    item $ do
      "Each experiment is composed by" <.> textbf "100 jobs" <.> "taken from" <.> textbf "PigMix"
      " and has been executed " <> textbf "5 times"

    vspace $ Cm 0.3
    pause

    item $ "HFSP compared to the " <> textbf "Fair Scheduler"
   
  where
    header = multirow 2 "*" (textbf "Bin")
           & multirow 2 "*" (shortstack "c" $ textbf "Dataset" <> lnbk <> textbf "Size")
           & multirow 2 "*" (shortstack "c" $ textbf "Averag. num." <> lnbk <> textbf "Map Tasks")
           & (multicolumn 3 [c] (textbf "Workload") <> lnbk <> cline 4 6
              <> "" & "" & "" & textbf "DEV" & textbf "TEST"& textbf "PROD" <> lnbk
              <> hline <> hline)


experimentsmetrics :: Monad m => LaTeXT_ m
experimentsmetrics = do
  frametitle "Performance Metrics"

  itemize $ do
    item $ do
      textbf "Mean Response Time"

      itemize $ do
        item "A job response time is the time passed between the job submission and when it completes"
        item $ do
          "The mean of the response times of all jobs indicates the "
          textbf "responsiveness"
          " of the system under that scheduling policy"

    vspace $ Cm 0.3
    pause

    item $ do
      textbf "Fairness"

      itemize $ do
        item $ do
          "A common approach is to use  the" <.> textbf "job slowdown"
          "," <.> emph "i.e." <.> "the ratio between job response time and"
          " its size, to indicate how fair the scheduler has been with that"
          " job"
        item $ do
          "In the literature a scheduler with"
          textbf " same or smaller slowdowns than the Processor Sharing"
          " is considered fair"


experiments :: Monad m => LaTeXT_ m
experiments = do
  frametitle "Results: Mean Response Time"

  tabular' [pm 0.33,pm 0.63] $ center (input "src/responsetimes.tex") & expl

  where expl = itemize $ do
        item $ "Overall HFSP decreases the mean response time of " <> textbf (raw "$\\sim$" <> "30%")

        pause
        vspace $ Cm 0.5

        item $ do
          textbf "Tiny jobs"
          " (bin 1) are treated in the same way by the two schedulers: they run as soon as possible"

        vspace $ Cm 0.3

        item $ do
          textbf "Medium, large" <.> "and" <.> textbf "huge"
          " jobs (bins 2, 3 and 4) are" <.> textbf "consistently treated better"
          " by HFSP thanks to its" <.> textbf "size-based sequential" <.> "nature"


experiments2 :: Monad m => LaTeXT_ m
experiments2 = do
  frametitle "Results: Fairness"
 
  vspace $ Cm (-1)

  center $ tabular' [pm 0.3,pm 0.3,pm 0.3] $ do
       figure' (do
         includegraphics [customwidth 0.30] "fig/slowdown_SMALL.pdf"
         caption "DEV workload"
         )
     & figure' (do
         includegraphics [customwidth 0.30] "fig/slowdown_MEDIUM.pdf"
         caption "TEST workload"
         )
     & figure' (do
         includegraphics [customwidth 0.30] "fig/slowdown_LARGE.pdf"
         caption "PROD workload"
         )

  vspace $ Cm (-1)

  itemize $ do
    item $ "HFSP is globally " <> textbf "more fair" <> " to jobs than the Fair Scheduler"

    vspace $ Cm 0.3

    item $ "The ``heavier'' the workload is, the better HFSP treats jobs compared to the Fair Scheduler"

    vspace $ Cm 0.3

    item $ do
      "For the PROD workload, the gap between the median under HFSP and the"
      " one under Fair is " <> textbf "one order of magnitude"


errors :: Monad m => LaTeXT_ m
errors = do
  frametitle "Task Times and Estimation Errors"

  tabular' [pm 0.45,pm 0.45] $ small ttdesc & figtt

  newline
  vfill
  pause

  tabular' [pm 0.35,pm 0.60] $ figerr & small errdesc

  where figtt = includegraphics [customwidth 0.40] "fig/sojourn_map_reduce_times_norm.pdf"

        ttdesc = itemize $ do
                  item $ "Tasks of a single job are " <> textbf "stable"
                  item $ "Even a " <> textbf "small number" <> " of training tasks is enough for estimating the phase size"

        figerr = includegraphics [customwidth 0.40] "fig/errors_cdf.pdf"

        errdesc = itemize $ do
                    item $ do
                      math $ "error = " <> frac ("est." <> raw "\\ " <> "size") ( "real" <> raw "\\ " <> "size")

                      itemize $ do
                        item $ do
                          math ("error > 1" <> rightarrow) <.> "estimated size is bigger than the real one ("
                          textbf "over-estimation" <> ")"
                        item $ do
                          math ("error < 1" <> rightarrow) <.> "estimated size is smaller than the real one ("
                          textbf "under-estimation" <> ")"
                    item $ do
                      "Biggest errors are on over-estimating map phases"
--                    item $ do
--                      textbf "Map" <> ": less than 5% are under-estimated"
--                      " by a factor of 0.4/0.5 and less than 4% are over-estimated by a factor of 2/3.5"
--                    item $ textbf "Reduce" <> ": under-estimation is negligible and 10% of jobs are over-estimated by a factor of 2"


errors2 :: Monad m => LaTeXT_ m
errors2 = do
  frametitle $ "Estimation Errors: Job Sizes and Phases"

  vspace $ Cm (-1)

  center $ tabular' [pm 0.4,pm 0.4] $
      figure' (do
        includegraphics [customwidth 0.4] "fig/errors_boxplot_maps.pdf"
        caption "Map Phase"
        )
    & figure' (do
        includegraphics [customwidth 0.4] "fig/errors_boxplot_reduces.pdf"
        caption "Reduce Phase"
        )

  vspace $ Cm (-0.8)

  itemize $ do
    item $ "Majority of estimated sizes are " <> textbf "close to the correct one"
    item $ "Tendency to" <.> textbf "over-estimate" <.> "in all the bins"
    item $ "Smaller errors on medium jobs (bin 2) compared to large and huge ons (bin 3 and 4)"
    item $ "Switching jobs is" <.> textbf "highly unlikely"


errorsFSP :: Monad m => LaTeXT_ m
errorsFSP = do
  frametitle "FSP with Estimation Errors"

  vspace $ Cm (-0.2)

  itemize $ do
    item $ do
      "Our experiments show that, in Hadoop, the estimation errors "
      textbf "don't impact" <> " our size-based scheduler performance"

    item $ do
      "Can we " <> textbf "abstract from Hadoop" <> " and extract a"
      textbf " general rule" <> " on the applicability of size-based scheduling policies?"

    vspace $ Cm 0.3
    pause

    item $ do
      textbf "Simulative approach"
      ": simulations are fast making possible to try "
      textbf "different workloads" <> "," <.> textbf "jobs arrival times" <.> "and" <.> textbf "errors"
    item $ do
      "Our results show that size-based schedulers, like FSP and SRPT, are "
      textbf "tolerant to errors" <.> "in many cases"

    vspace $ Cm 0.3
    pause

    item $ do
      "We created" <.> textbf "FSP+PS" <.> "that tolerates even more ``extreme'' conditions [MASCOTS 2014]"


kill :: Monad m => LaTeXT_ m
kill = do
  frametitle "Task Preemption in HFSP"

  itemize $ do
    item $ do
      "In " <> textbf "theory"

      itemize $ do
        item $ do
          "Preemption consists in " <> textbf "removing resources"
          " from a running job  and granting them to another one"
        item $ do
          "Without knowledge of the workload, preemptive schedulers "
          textbf "outmatch" <> " their non-preemptive counterparts"

    vspace $ Cm 0.3
    pause

    item $ do
      "In " <> textbf "practice"

      itemize $ do
        item $ "Preemption is " <> textbf "difficult to implement"

        pause

        item $ do
          "In " <> textbf "Hadoop"
          itemize $ do
            item $ do
              "Task preemption support through the" <.> textbf "kill"
              " primitive: it removes resources from a task by "
              textbf "killing it" <.> math rightarrow <.> textbf "all work is lost!"
            item "Kill disadvantages are well known and usually it is disabled or used very carefully"
            item $ textbf "HFSP" <.> "is a preemptive scheduler and" <.> textbf "supports the task kill primitive"


killres :: Monad m => LaTeXT_ m
killres = do
  frametitle "Results: Kill Preemption"

  vspace $ Cm (-0.5)

  center $ tabular (Just Top) [pm 0.4,pm 0.4] $
      includegraphics [customwidth 0.40] "fig/kill_vs_wait_slowdown.pdf"
    & includegraphics [customwidth 0.40] "fig/kill_vs_wait_sojourntime.pdf"

  itemize $ do
    item $ "Kill " <> textbf "improves fairness and response times of small and medium jobs" <> ldots
    item $ ldots <> "but " <> textbf "impacts heavily" <> " large jobs response times"


suspfast :: Monad m => LaTeXT_ m
suspfast = do
  frametitle "OS-Assisted Preemption"

  itemize $ do
    item $ do
      "Kill preemption is " <.> textbf "non-optimal" <> ": it preempts running "
      "tasks but has a" <.> textbf "high cost"
    item $ do
      "Can we do a mechanism that is more similar to an" <.> textbf "ideal preemption?"

    pause

    item $ do
      "Idea" <.> ldots

      itemize $ do
        item $ do
          "Instead of killing a task, we can" <.> textbf "suspend" <.> "it where it is running"
        item $ do
          "When the task should run again, we can" <.> textbf "resume" <.> "it where it was running"


    item $ do
      ldots <.> "but how can be implemented?"

      pause

      itemize $ do
        item $ do
          textbf "Operating Systems" <.> "know very well how to" <.> textbf "suspend and resume processes"
        item $ do
          "At low-level," <.> textbf "tasks are processes"
        item $ do
          "Exploit OS capabilities to get a new preemption primitive: " <.> textbf "Task Suspension" <.> "[DCPERF 2014]"


conclusion :: Monad m => LaTeXT_ m
conclusion = do
  frametitle "Conclusion"

  itemize $ do
    item $ do
      "Size-based schedulers with estimated (imprecise) sizes can "
      textbf "outperform" <> " schedulers not size-based in real systems"

    vspace $ Cm 0.3
    pause

    item $ do
      "We showed this by designing the" <.> textbf "Hadoop Fair Sojourn Protocol"
      ", a size-based scheduler for a" <.> textbf "real" <.> "and"
      textbf " distributed" <.> "system such as Hadoop"

    vspace $ Cm 0.3
    pause

    item $ "HFSP is" <.> textbf "fair" <.> "and achieves " <> textbf "small mean response time"

    vspace $ Cm 0.3
    pause

    item $ do
      "It can also use Hadoop preemption mechanism to improve fairness"
      " and response times of small jobs, but this will affect the performance"
      " of large and huge jobs"


-- backup slides

futurework :: Monad m => LaTeXT_ m
futurework = do
  frametitle "Future Work"

  itemize $ do
    item $ do
      textbf "HFSP + Suspension" <> ": adding the suspension mechanism to HFSP"
      " raises many challenges, such as the eviction policy and the reduce locality"

    vspace $ Cm 0.3

    item $ do
      textbf "Recurring Jobs"
      ": exploit the past runs of recurring jobs to obtain an almost"
      " perfect estimation since their submission."

    vspace $ Cm 0.3

    item $ do
      textbf "Complex Jobs" <> ": high-level languages and libraries push the scheduling"
      " problem from simple jobs to complex jobs, that are chains of simple jobs."
      " Can we adapt HFSP to such jobs?"


overunderest :: Monad m => LaTeXT_ m
overunderest = do
  frametitle "Impact of Over-estimation and Under-estimation"

  center $ figure' $
    includegraphics [customwidth 0.5] "fig/over-under_estimation.pdf"

  itemize $ do
    item $ textbf "Over-estimating" <.> "a job affects only that job. Other jobs in queue are not affected"
    item $ textbf "Under-estimating" <.> "a job can affect other jobs in queue"


fspps :: Monad m => LaTeXT_ m
fspps = do
  frametitle "FSP+PS"

  itemize $ do
    item $ do
      "In FSP, under-estimated jobs can complete in the virtual system"
      " before than in the real system. We call them" <.> textbf "late jobs"

    vspace $ Cm 0.5

    item $ do
      "When a job is late, it" <.> textbf "should not prevent" <.> "executing other jobs"

    vspace $ Cm 0.5

    item $ do
      "FSP+PS solves the problem by scheduling late jobs using" <.> textbf "processor sharing"



susp1 :: Monad m => LaTeXT_ m
susp1 = do
  frametitle "OS-Assisted Task Preemption"

  textbf "Kill" <> " preemption primitive has many drawbacks, can we do better?"

  vspace $ Cm 0.3
  pause

  itemize $ do
    item $ do
      "At low level, tasks are" <.> textbf "processes" <.> "and processes"
      " can be" <.> textbf "suspended" <.> "and" <.> textbf "resumed" <.> "by the Operating System"

    pause

    item $ "We exploit this mechanism by enabling " <> textbf "task suspension and resuming"

    pause

    item $ "No need to change existent jobs! Done at low-level and transparent to the user"

    pause

    item $ do
      "Bonus: the operating system manages the memory of processes"
      itemize $ do
        item $ "Memory of suspended tasks can be granted to other (running) tasks by the OS" <> ldots
        item $ do
          ldots <> " and because the OS knows how much memory the process needs, only the"
          " memory required will be taken from the suspended task"


susptrash :: Monad m => LaTeXT_ m
susptrash = do
  frametitle "OS-Assisted Task Preemption: Trashing"

  itemize $ do
    item $ do
      textbf "Trashing" <> ": when data is continuously read from and written to swap space"
      ", the machine performance are highly degraded to a point that the machine doesn't work properly anymore"

    vspace $ Cm 0.3

    item $ do
      "Trashing is caused by the" <.> textbf "working set" <.> "(memory) that is "
      textbf "larger than the system memory"

    vspace $ Cm 0.3
    pause

    item $ do
      "In Hadoop this doesn't happen because:"
      itemize $ do
        item $ textbf "Running tasks" <> " per machine are limited"
        item $ textbf "Heap space" <> " per task is limited"


suspexp :: Monad m => LaTeXT_ m
suspexp = do
  frametitle "OS-Assisted Task Preemption: Experiments"

  itemize $ do
    item $ "Test the " <> textbf "worst case" <> " for suspension, that is when the jobs allocate all the memory"
    item $ "Two jobs, " <> raw "$t_h$" <> " and " <> raw"$t_l$" <> ", allocating 2 GB of memory"

  center $ tabular' [pm 0.4,pm 0.4] $
      includegraphics [customwidth 0.40] "fig/j2finishtime_2gb_20runs.pdf"
    & includegraphics [customwidth 0.40] "fig/makespan_2gb_20runs.pdf"
 
  vspace $ Cm (-0.3)

  itemize $ do
    item $ "Our primitive outperform " <> textbf "kill" <> " and " <> textbf "wait"
    item $  "Overhead for swapping doesn't affect the jobs too much"


suspconc :: Monad m => LaTeXT_ m
suspconc = do
  frametitle "OS-Assisted Task Preemption: Conclusions"

  itemize $ do
    item $ textbf "Task Suspension/Resume" <> " outperform current preemption implementations" <> ldots

    vspace $ Cm 0.3
    pause

    item $ ldots <> "but it raises new challenges, " <> emph "e.g." <> textbf " state locality" <> " for task suspended"

    vspace $ Cm 0.3
    pause

    item $ "With a good scheduling policy (and eviction policy), OS-assisted preemption can substitute current preemption mechanism"
